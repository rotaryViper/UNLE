<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WCNL Testing</title>
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@7.x/dist/pixi.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        #canvas {
            max-width: 720px;
            max-height: 720px;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>
</head>
<body>
    <div id="canvas"></div>
    <script>
        "use strict"
        // TODO: Fix this later
        let dragTarget = null;

        const numNodes = 400;
        
        // Make random edges
        let testEdges = new Array(numNodes-1);

        for (var i = 0; i < testEdges.length; i++) {
            testEdges[i] = [i, i+1, 0];
        };

        //console.log(testEdges)

        var nodesEdgeNum = 3;

        /*This is equal to 10000000000^0.16
        The reason it is in its own variable is to reduce the amount of processing in this function.
        To change it just recalculate it.*/
        const constant = 39.8107170553

        function onDragMove(event) {
            if (!dragTarget) 
                return;
            
            dragTarget.parent.toLocal(event.global, null, dragTarget.position);
            locked.x = dragTarget.x;
            locked.y = dragTarget.y;
            applyEdgePower();
            spaceEdgesOnNode();
            constrainToBounds();
            //applyCollisions(); // Commenting this line frees up so much cpu time
            drawLines();
            
        }

        function onDragStart() {
            // store a reference to the data
            // the reason for this is because of multitouch
            // we want to track the movement of this particular touch
            // this.data = event.data;
            this.alpha = 0.9;
            dragTarget = this;
            app.stage.on('pointermove', onDragMove);
            shouldLock = true;
            locked.x = dragTarget.x;
            locked.y = dragTarget.y;
        }

        function onDragEnd() {
            if (dragTarget) {
                app.stage.off('pointermove', onDragMove);
                dragTarget.alpha = 1;
                // Testing:
                //console.log(dragTarget)
                dragTarget = null;

                /* Redundant by main function
                applyEdgePower();
                spaceEdgesOnNode();
                constrainToBounds();
                applyCollisions();
                drawLines();
                */
                shouldLock = false;
            }
        }

        var noDiff = false;
        var shouldLock = false;
        var locked = {
            x: 0,
            y: 0,
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function main() {
            while (true) {
                if (noDiff){
                    await sleep(16);
                    console.log("waiting!")
                    continue;
                } else if (shouldLock) {
                    dragTarget.x = locked.x;
                    dragTarget.y = locked.y;
                }
                applyEdgePower();
                spaceEdgesOnNode();
                constrainToBounds();
                applyCollisions();
                drawLines();
                await sleep(16);
            }
        }

        function toDegrees(angle) {
            return angle * (180 / Math.PI);
        }

        function toRadians(angle) {
            return angle * (Math.PI / 180);
        }
    </script>
    <script>
        "use strict"
        const app = new PIXI.Application({
            resolution: 2,
            antialias: true
        });

        //This is neccessary to reuse the same texture for a simple line
        const lineG = new PIXI.Graphics();
        lineG.beginFill(0xFFFFFF, 1);
        lineG.drawRect(0,0,1,1);
        lineG.endFill();
        const lineT = app.renderer.generateTexture(lineG);

        // TODO: rename all "node" to "vertex"

        var textOptions = {
            font: "bold 64px Roboto", // Set  style, size and font
            fill: '#FFFFFF', // Set fill color to blue
            align: 'center', // Center align the text, since it's multiline
            stroke: '#000000', // Set stroke color to a dark blue gray color
            strokeThickness: 2, // Set stroke thickness to 20
            lineJoin: 'round' // Set the lineJoin to round
        }
        
        document.getElementById("canvas").appendChild(app.view);

        // This is supposed to be deprecated... Find a better way to do this.
        app.stage.eventMode = 'dynamic'; // Changed interactive to eventMode
        //
        app.stage.hitArea = app.screen;
        app.stage.on('pointerup', onDragEnd);
        app.stage.on('pointerupoutside', onDragEnd);

        // The containers are ordered as such that the lines are drawn underneath the nodes.
        const LinesContainer = new PIXI.Container();
        app.stage.addChild(LinesContainer);
        const NodesContainer = new PIXI.Container();
        app.stage.addChild(NodesContainer);

        // get a random value between stage.width and 0
        function randomX() {
            return Math.floor(Math.random() * app.screen.width);
        }

        function randomY() {
            return Math.floor(Math.random() * app.screen.height);
        }

        function randomColour() {
            return Math.floor(Math.random() * 0xFFFFFF);
        }

        function randomRadius() {
            return Math.floor(Math.random() * 25) + 15;
        }

        function randomEdgePower() {
            return Math.floor(Math.random() * 150) + 70;
        }


        for(var i = 0; i < numNodes; i++) {
            createNode(randomX(), randomY(), 20, 0x3A3A3A, i)
        }

        for(var i = 0; i < testEdges.length; i++) {
            testEdges[i][2] = 100;
        }
        
        /* Redundant by main function
        applyEdgePower();
        constrainToBounds();
        applyCollisions();
        drawLines();
        spaceEdgesOnNode();
        */

        main();

        function createNode(x, y, rad, colour, text) {

            // Replaced graphics with sprite for faster rendering
            const nodeG = new PIXI.Graphics();
            //nodeG.lineStyle(2, 0xa0a0a0 | colour, 1);
            nodeG.beginFill(colour, 1);
            nodeG.drawCircle(0, 0, rad);
            nodeG.endFill();

            // Moved text into texture
            const annotation = new PIXI.Text(text, textOptions);
            annotation.anchor.set(0.5); 


            const nodeContainer = new PIXI.Container();
            nodeContainer.addChild(nodeG);
            nodeContainer.addChild(annotation);

            const nodeT = app.renderer.generateTexture(nodeContainer);
            const node = new PIXI.Sprite(nodeT);
            node.anchor.set(0.5);

            node.eventMode = 'dynamic'; // Changed interactive to eventMode
            node.on('pointerdown', onDragStart, node);
            node.x = x;
            node.y = y;
            NodesContainer.addChild(node);
            return node;
        }

        // TODO: add line styles such as a directed line (just an arrow going from one node to another)

        // Implementing arrows with textured sprites is quite complicated

        function drawLine(x1, y1, x2, y2, width, colour, value) {
            const dx = x2-x1;
            const dy = y2-y1;

            const line = new PIXI.Sprite(lineT);
            line.x = x2;
            line.y = y2;
            line.height = Math.sqrt((dx*dx) + (dy*dy));
            line.width = width;

            line.angle = -(Math.atan2(dx, dy) * 180 / Math.PI) - 180;

            app.stage.addChild(line);

            //var annotation = new PIXI.Text(value, textOptions);
            //annotation.anchor.set(0.5);
            //line.addChild(annotation);

            LinesContainer.addChild(line);
            return line;
        }

        // Implement this fully later
        function drawLines() {
            LinesContainer.removeChildren();
            for (var i = 0; i < testEdges.length; i++) {
                drawLine(
                    app.stage.children[1].children[testEdges[i][0]].x,
                    app.stage.children[1].children[testEdges[i][0]].y,
                    app.stage.children[1].children[testEdges[i][1]].x,
                    app.stage.children[1].children[testEdges[i][1]].y,
                    3,
                    0xC0C0C0,
                    testEdges[i][2]
                )
            }
        }

        function applyCollisions() {
            for (let x = 0; x < 3; x++) {
                for (let i = 0; i < NodesContainer.children.length; i++) {
                    for (let j = 0; j < NodesContainer.children.length; j++) {
                        if (i != j) {
                            const a = NodesContainer.children[i]
                            const b = NodesContainer.children[j]
                            const dx = b.x - a.x
                            const dy = b.y - a.y
                            const dist = Math.sqrt(dx * dx + dy * dy)
                            const minDist = (a.width + b.width) * 0.5
                            if (dist < minDist) {
                                const angle = Math.atan2(dy, dx)
                                const tx = a.x + Math.cos(angle) * minDist
                                const ty = a.y + Math.sin(angle) * minDist
                                const ax = (tx - b.x) * 0.5
                                const ay = (ty - b.y) * 0.5
                                a.x -= ax
                                a.y -= ay
                                b.x += ax
                                b.y += ay
                            }
                        }
                    }
                }
            }
        }

        // testEdges

        function applyEdgePower() {
            var difference = false;
            for (var x = 0; x < 2; x++) {
                // Apply a force to each node based on the edges
                for (var i = 0; i < testEdges.length; i++) {
                    NodesContainer.children[testEdges[i][0]]
                    // get the difference between the target node and the current node
                    var dx = NodesContainer.children[testEdges[i][1]].x - NodesContainer.children[testEdges[i][0]].x
                    var dy = NodesContainer.children[testEdges[i][1]].y - NodesContainer.children[testEdges[i][0]].y

                    var edgeLen = testEdges[i][2]

                    var dist = Math.sqrt(dx * dx + dy * dy)

                    // if the distance is within 10% + or - of the edge length, don't apply a force
                    if (dist > edgeLen * 0.95 && dist < edgeLen * 1.05) 
                        continue;

                    difference = true;

                    var diff = edgeLen - dist

                    var percent = diff / (dist * constant)

                    var offsetX = dx * percent
                    var offsetY = dy * percent

                    NodesContainer.children[testEdges[i][0]].x -= offsetX
                    NodesContainer.children[testEdges[i][0]].y -= offsetY
                    NodesContainer.children[testEdges[i][1]].x += offsetX
                    NodesContainer.children[testEdges[i][1]].y += offsetY


                }
            }

            if (!difference) {
                noDiff = true;
            } else {
                noDiff = false;
            }
        }

        function constrainToBounds() {
            // ensure all nodes are within the bounds of the canvas
            for (var i = 0; i < NodesContainer.children.length; i++) {
                var node = NodesContainer.children[i]
                if (node.x < 0) node.x = 0
                if (node.y < 0) node.y = 0
                if (node.x > app.screen.width) node.x = app.screen.width
                if (node.y > app.screen.height) node.y = app.screen.height
            }
        }

        function spaceEdgesOnNode() {
            for (var i = 0; i < numNodes; i++) {
                if (nodesEdgeNum == 0) {
                    var angle = 360;
                } else {
                    var angle = 360 / nodesEdgeNum;
                }
                var connectedNodes = []
                for (var k = 0; k < testEdges.length; k++) {
                    if (testEdges[k][0] == i && testEdges[k][1] != i) {
                        connectedNodes.push([testEdges[k][1], testEdges[k][2]])
                    } else if (testEdges[k][1] == i && testEdges[k][0] != i) {
                        connectedNodes.push([testEdges[k][0], testEdges[k][2]])
                    }
                }

                // Initialize the angles array to house all of the possible angles for degrees of the vertex / node.
                var angles = Array(nodesEdgeNum);

                for (var j = 0; j < nodesEdgeNum; j++) {
                    angles[j] = angle * j;
                }

                for (var j = 0; j < connectedNodes.length; j++) {

                    var dx = NodesContainer.children[i].x - NodesContainer.children[connectedNodes[j][0]].x;
                    var dy = NodesContainer.children[i].y - NodesContainer.children[connectedNodes[j][0]].y;
                    var dist = connectedNodes[j][1];

                    //var currentAngle = toDegrees(Math.atan2(dy, dx));

                    //var closestAngle = Math.abs(Math.round(currentAngle / angle) * angle)

                    // find the index of the closest angle in angles to the current angle
                    
                    var offsetX = (dist) * Math.sin(toRadians(angles[j])) / constant;
                    var offsetY = (dist) * Math.cos(toRadians(angles[j])) / constant;

                    // move the node towards the position
                    NodesContainer.children[connectedNodes[j][0]].x += offsetX;
                    NodesContainer.children[connectedNodes[j][0]].y += offsetY;

                    // now move the current node in the opposite angle to the position
                    NodesContainer.children[i].x -= offsetX;
                    NodesContainer.children[i].y -= offsetY;
                    
                }
            }
        }
    </script>
</body>
</html>